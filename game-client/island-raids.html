<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Island Raids - Crypto Tower Defense</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèùÔ∏è</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: white;
            min-height: 100vh;
            background-image:
                radial-gradient(circle at 20% 50%, rgba(59, 130, 246, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 50%, rgba(16, 185, 129, 0.1) 0%, transparent 50%);
            background-attachment: fixed;
        }

        /* Header */
        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
            backdrop-filter: blur(10px);
            border-bottom: 2px solid #3b82f6;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
        }

        .back-btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: 2px solid #60a5fa;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Press Start 2P';
            font-size: 10px;
            transition: all 0.3s;
        }

        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5);
        }

        .header-title {
            font-size: 16px;
            color: #fbbf24;
            text-shadow: 2px 2px 0 #000;
        }

        /* Main Container */
        .container {
            margin-top: 80px;
            padding: 20px;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
        }

        /* World Map View */
        #worldMapView {
            display: block;
        }

        .map-title {
            text-align: center;
            font-size: 24px;
            color: #fbbf24;
            margin-bottom: 30px;
            text-shadow: 3px 3px 0 #000;
        }

        .islands-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .island-card {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 2px solid #3b82f6;
            border-radius: 16px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .island-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, #3b82f6, #10b981, #fbbf24);
        }

        .island-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.5);
            border-color: #fbbf24;
        }

        .island-name {
            font-size: 16px;
            color: #fbbf24;
            margin-bottom: 10px;
        }

        .island-difficulty {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 15px;
        }

        .island-progress {
            background: #0f172a;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .island-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #34d399);
            transition: width 0.5s;
        }

        /* Battle View */
        #battleView {
            display: none;
        }

        .battle-stage {
            background: linear-gradient(135deg, #1e293b, #0f172a);
            border: 2px solid #3b82f6;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 20px;
        }

        .stage-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .stage-name {
            font-size: 18px;
            color: #fbbf24;
            margin-bottom: 10px;
        }

        .hp-bars {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 30px;
        }

        .hp-container {
            flex: 1;
        }

        .hp-label {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 5px;
        }

        .hp-bar-bg {
            background: #0f172a;
            height: 25px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid #475569;
        }

        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #34d399);
            transition: width 0.5s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .boss-hp .hp-bar {
            background: linear-gradient(90deg, #ef4444, #f87171);
        }

        .battle-arena {
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 300px;
            position: relative;
        }

        .team-side {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .character-sprite {
            width: 100px;
            margin: 0 15px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .character-sprite-img {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: 3px solid #60a5fa;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            font-size: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Individual HP Bar for each character */
        .char-hp-container {
            width: 100%;
            margin-top: 5px;
        }

        .char-hp-bar-bg {
            background: #1e293b;
            border: 2px solid #475569;
            border-radius: 8px;
            height: 12px;
            overflow: hidden;
            position: relative;
        }

        .char-hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #34d399);
            transition: width 0.5s ease, background 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .char-hp-bar.hp-low {
            background: linear-gradient(90deg, #ef4444, #f87171);
        }

        .char-hp-bar.hp-medium {
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
        }

        .char-hp-text {
            font-size: 8px;
            color: white;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .character-sprite.fainted {
            opacity: 0.3;
            filter: grayscale(100%);
        }

        .boss-side {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .boss-sprite {
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: 4px solid#fbbf24;
            border-radius: 16px;
            background-size: cover;
            background-position: center;
        }

        /* Battle Controls */
        .battle-controls {
            margin-top: 20px;
        }

        .action-menu {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .menu-btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: 2px solid #60a5fa;
            color: white;
            padding: 20px;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'Press Start 2P';
            font-size: 14px;
            transition: all 0.3s;
        }

        .menu-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.7);
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Move Selection */
        .move-selection {
            background: rgba(15, 23, 42, 0.95);
            border: 2px solid #475569;
            border-radius: 12px;
            padding: 20px;
            display: none;
        }

        .move-selection h3 {
            color: #fbbf24;
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
        }

        .moves-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .move-btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: 2px solid #60a5fa;
            padding: 15px;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            text-align: left;
            font-family: 'Press Start 2P';
            font-size: 10px;
            transition: all 0.3s;
        }

        .move-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.7);
        }

        .move-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .move-btn.type-FIRE {
            background: linear-gradient(135deg, #f59e0b, #dc2626);
            border-color: #fbbf24;
        }

        .move-btn.type-WATER {
            background: linear-gradient(135deg, #3b82f6, #1e40af);
            border-color: #60a5fa;
        }

        .move-btn.type-GRASS {
            background: linear-gradient(135deg, #10b981, #047857);
            border-color: #34d399;
        }

        .move-btn.type-ELECTRIC {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-color: #fde047;
        }

        .move-btn.type-NORMAL {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            border-color: #9ca3af;
        }

        .move-btn.type-ICE {
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            border-color: #93c5fd;
        }

        .move-name {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .move-details {
            font-size: 8px;
            opacity: 0.9;
        }

        .pp-low {
            color: #ef4444;
        }

        .pp-ok {
            color: #10b981;
        }

        /* Battle Log */
        .battle-log {
            background: #0f172a;
            border: 2px solid #475569;
            border-radius: 12px;
            padding: 15px;
            height: 150px;
            overflow-y: auto;
            margin-top: 20px;
            font-size: 10px;
        }

        .battle-log div {
            margin-bottom: 5px;
        }

        /* Animations */
        /* === PHASE 14: BATTLE ANIMATIONS === */
        @keyframes attackMove {
            0% {
                transform: translateX(0);
            }

            40% {
                transform: translateX(30px);
            }

            60% {
                transform: translateX(30px);
            }

            100% {
                transform: translateX(0);
            }
        }

        @keyframes enemyAttackMove {
            0% {
                transform: translateX(0);
            }

            40% {
                transform: translateX(-30px);
            }

            60% {
                transform: translateX(-30px);
            }

            100% {
                transform: translateX(0);
            }
        }

        @keyframes hitShake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-8px);
            }

            50% {
                transform: translateX(8px);
            }

            75% {
                transform: translateX(-8px);
            }
        }

        @keyframes faintAnimation {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            50% {
                opacity: 0.5;
                transform: translateY(10px) scale(0.9);
            }

            100% {
                opacity: 0.3;
                transform: translateY(20px) scale(0.8);
                filter: grayscale(100%);
            }
        }

        @keyframes damageFlash {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(2.5) saturate(0);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .anim-attack {
            animation: attackMove 0.6s ease-in-out;
        }

        .anim-enemy-attack {
            animation: enemyAttackMove 0.6s ease-in-out;
        }

        .anim-hit {
            animation: hitShake 0.3s ease-in-out, damageFlash 0.2s ease-in-out;
        }

        .anim-faint {
            animation: faintAnimation 0.5s ease-out forwards;
        }

        .anim-pulse {
            animation: pulse 0.3s ease-in-out;
        }

        /* Damage number animations */
        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px) scale(1.2);
                opacity: 0;
            }
        }

        .dmg-number {
            position: fixed;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            z-index: 9999;
            animation: floatUp 1s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .player-dmg {
            color: #fbbf24;
        }

        .player-dmg-super {
            color: #10b981;
            font-size: 28px;
        }

        .player-dmg-weak {
            color: #94a3b8;
            font-size: 20px;
        }

        .enemy-dmg {
            color: #ef4444;
        }

        /* === END ANIMATIONS === */

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }

            100% {
                opacity: 0;
                transform: translateY(-100px);
            }
        }

        @keyframes flash-hit {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(2);
            }
        }

        .flash-hit {
            animation: flash-hit 0.3s;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-10px);
            }

            75% {
                transform: translateX(10px);
            }
        }

        .shaking {
            animation: shake 0.5s;
        }

        /* Damage Numbers */
        .dmg-number {
            position: fixed;
            font-family: 'Press Start 2P';
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            z-index: 999;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
        }

        .dmg-number.player-dmg {
            color: #fbbf24;
        }

        .dmg-number.player-dmg-super {
            color: #10b981;
        }

        .dmg-number.player-dmg-weak {
            color: #ef4444;
        }

        .dmg-number.team-dmg {
            color: #ef4444;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #1e293b;
            padding: 30px;
            border-radius: 16px;
            border: 2px solid #3b82f6;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-title {
            color: #fbbf24;
            font-size: 18px;
            margin-bottom: 20px;
            text-align: center;
        }

        .mission-item {
            background: #0f172a;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mission-item:hover {
            transform: translateX(5px);
            border-color: #fbbf24;
        }

        .mission-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-close {
            width: 100%;
            padding: 15px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Press Start 2P';
            font-size: 12px;
            margin-top: 20px;
        }

        /* EMOJI SPRITES SYSTEM (Phase 11) */
        .emoji-sprite {
            font-size: 80px;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            transition: transform 0.2s;
            cursor: default;
            user-select: none;
        }

        .emoji-sprite.boss {
            font-size: 120px;
            filter: drop-shadow(0 0 15px rgba(239, 68, 68, 0.4));
        }

        /* Idle Animations */
        @keyframes float-breathing {

            0%,
            100% {
                transform: translateY(0) scale(1.0);
            }

            50% {
                transform: translateY(-5px) scale(1.02);
            }
        }

        .anim-idle {
            animation: float-breathing 3s infinite ease-in-out;
        }

        /* Attack Animations */
        @keyframes attack-lunge-right {
            0% {
                transform: translateX(0);
            }

            30% {
                transform: translateX(-20px) rotate(-5deg);
            }

            /* Windup */
            60% {
                transform: translateX(60px) rotate(10deg);
            }

            /* Strike */
            100% {
                transform: translateX(0);
            }
        }

        @keyframes attack-lunge-left {
            0% {
                transform: translateX(0);
            }

            30% {
                transform: translateX(20px) rotate(5deg);
            }

            /* Windup */
            60% {
                transform: translateX(-60px) rotate(-10deg);
            }

            /* Strike */
            100% {
                transform: translateX(0);
            }
        }

        .anim-attack-right {
            animation: attack-lunge-right 0.6s ease-in-out;
        }

        .anim-attack-left {
            animation: attack-lunge-left 0.6s ease-in-out;
        }

        .anim-hit {
            animation: shake 0.4s ease-in-out, flash-hit 0.4s ease-in-out;
        }

        /* CUSTOM NOTIFICATION SYSTEM (Phase 12) */
        .game-notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 3px solid #3b82f6;
            border-radius: 16px;
            padding: 30px 40px;
            box-shadow: 0 20px 60px rgba(59, 130, 246, 0.4), 0 0 0 1000px rgba(0, 0, 0, 0.7);
            z-index: 10000;
            min-width: 350px;
            max-width: 500px;
            font-family: 'Press Start 2P', monospace;
            animation: modalSlideIn 0.3s ease-out;
            display: none;
        }

        @keyframes modalSlideIn {
            from {
                transform: translate(-50%, -60%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .game-notification.error {
            border-color: #ef4444;
            box-shadow: 0 20px 60px rgba(239, 68, 68, 0.4), 0 0 0 1000px rgba(0, 0, 0, 0.7);
        }

        .game-notification.success {
            border-color: #10b981;
            box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4), 0 0 0 1000px rgba(0, 0, 0, 0.7);
        }

        .game-notification.warning {
            border-color: #f59e0b;
            box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4), 0 0 0 1000px rgba(0, 0, 0, 0.7);
        }

        .notif-title {
            color: #fbbf24;
            font-size: 16px;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
        }

        .notif-message {
            color: #e2e8f0;
            font-size: 11px;
            line-height: 1.6;
            margin-bottom: 20px;
            text-align: center;
        }

        .notif-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .notif-btn {
            padding: 12px 24px;
            border: 2px solid #3b82f6;
            background: linear-gradient(135deg, #3b82f6, #1e40af);
            color: white;
            font-family: 'Press Start 2P';
            font-size: 10px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .notif-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(59, 130, 246, 0.5);
        }

        .notif-btn.cancel {
            background: linear-gradient(135deg, #6b7280, #374151);
            border-color: #6b7280;
        }

        .notif-btn.danger {
            background: linear-gradient(135deg, #ef4444, #991b1b);
            border-color: #ef4444;
        }
    </style>
    <link rel="stylesheet" href="css/modals.css">
</head>

<body>
    <!-- Custom Notification Modal -->
    <div id="gameNotification" class="game-notification">
        <div class="notif-title" id="notifTitle">NOTIFICATION</div>
        <div class="notif-message" id="notifMessage"></div>
        <div class="notif-buttons" id="notifButtons"></div>
    </div>

    <header>
        <button class="back-btn" onclick="location.href='game.html'">‚Üê BACK TO HUB</button>
        <div class="header-title">ISLAND RAIDS</div>
        <div style="width: 150px;"></div>
    </header>

    <div class="container">
        <!-- World Map View -->
        <div id="worldMapView">
            <h1 class="map-title">SELECT YOUR DESTINATION</h1>
            <div class="islands-grid" id="islandsGrid"></div>
        </div>

        <!-- Battle View -->
        <div id="battleView">
            <!-- Turn Indicator (Phase 13 - Axie Style) -->
            <div class="turn-indicator" id="turnIndicator" style="display: none;">
                <div style="text-align: center; margin-bottom: 10px;">
                    <div style="font-size: 16px; color: #fbbf24; font-family: 'Press Start 2P';" id="currentTurnText">
                        Loading...</div>
                    <div style="font-size: 9px; color: #94a3b8; margin-top: 5px;" id="turnQueuePreview">Next: ...</div>
                </div>
            </div>

            <div class="battle-stage">
                <div class="stage-header">
                    <div class="stage-name" id="stageName">Loading...</div>
                </div>
                <div class="battle-header">
                    <div class="hp-bars">
                        <!-- Individual character HP bars shown below each sprite -->
                    </div>
                </div>

                <div class="battle-arena">
                    <div class="team-side" id="teamSprites"></div>
                    <div class="boss-side">
                        <div class="boss-sprite" id="bossSprite"></div>
                        <!-- Boss HP bar below sprite -->
                        <div class="char-hp-container" style="width: 150px; margin-top: 10px;">
                            <div class="char-hp-bar-bg">
                                <div class="char-hp-bar" id="bossHpBar" style="width: 100%;">
                                    <span class="char-hp-text" id="bossHpText">500/500</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="battle-controls">
                    <div id="mainActionMenu" class="action-menu">
                        <button class="menu-btn" id="btnFight">FIGHT</button>
                        <button class="menu-btn" id="btnBag" disabled>BAG</button>
                        <button class="menu-btn" id="btnSwitch">SWITCH</button>
                        <button class="menu-btn" id="btnRun">RUN</button>
                    </div>

                    <div id="moveSelectionMenu" class="move-selection">
                        <h3>SELECT MOVE</h3>
                        <div class="moves-grid" id="movesGrid"></div>
                        <button class="menu-btn" onclick="showMainMenu()" style="margin-top: 10px;">‚Üê BACK</button>
                    </div>
                </div>

                <div class="battle-log" id="battleLog"></div>
                <div class="battle-log" id="battleLog"></div>
            </div>
        </div>
    </div>
    <header>
        <button class="back-btn" onclick="location.href='game.html'">‚Üê BACK TO HUB</button>
        <div class="header-title">ISLAND RAIDS</div>
        <div style="width: 150px;"></div>
    </header>

    <!-- Missions Modal -->
    <div class="modal" id="missionsModal">
        <div class="modal-content">
            <h2 class="modal-title" id="modalTitle">Select Mission</h2>
            <div id="missionsList"></div>
            <button class="btn-close" id="btnCloseModal">CLOSE</button>
        </div>
    </div>

    <!-- Victory Rewards Modal (Phase 12) -->
    <div class="modal" id="victoryModal" style="display: none;">
        <div class="modal-content" style="max-width: 600px;">
            <h2 class="modal-title" style="color: #10b981;">üèÜ VICTORY!</h2>
            <div style="margin: 20px 0;">
                <div style="font-size: 14px; color: #fbbf24; margin-bottom: 10px;">Performance: <span
                        id="victoryGrade">S</span></div>
                <div style="font-size: 12px; color: #e2e8f0;">GTK Earned: <span id="victoryTokens">0</span></div>

                <!-- Drops Section -->
                <div id="victoryDrops"
                    style="margin-top: 10px; display: flex; gap: 5px; flex-wrap: wrap; justify-content: center;"></div>

                <hr style="border-color: #374151; margin: 15px 0;">
                <div style="font-size: 12px; color: #9ca3af; margin-bottom: 5px;">XP GAINED</div>
                <div id="victoryXpBreakdown"></div>
            </div>
            <button class="btn-close" onclick="closeVictoryModal()">CONTINUE</button>
        </div>
    </div>

    <!-- Auth System -->
    <script src="js/auth.js"></script>
    <script src="js/token-manager.js"></script>

    <script>
        // === API CLIENT (Inline Implementation) ===
        const apiClient = {
            baseURL: 'http://localhost:8080/api/v1',

            async request(method, endpoint, data = null) {
                const token = localStorage.getItem('token');
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                }

                const options = {
                    method,
                    headers,
                    credentials: 'include'
                };

                if (data && (method === 'POST' || method === 'PUT')) {
                    options.body = JSON.stringify(data);
                }

                const response = await fetch(this.baseURL + endpoint, options);

                if (!response.ok) {
                    const error = await response.json().catch(() => ({ error: response.statusText }));
                    throw new Error(error.error || error.message || 'Request failed');
                }

                return response.json();
            },

            get(endpoint) {
                return this.request('GET', endpoint);
            },

            post(endpoint, data) {
                return this.request('POST', endpoint, data);
            },

            put(endpoint, data) {
                return this.request('PUT', endpoint, data);
            },

            delete(endpoint) {
                return this.request('DELETE', endpoint);
            }
        };

        // === CUSTOM NOTIFICATION SYSTEM (Phase 12) ===
        function showNotification(message, type = 'info', title = 'NOTIFICATION') {
            const modal = document.getElementById('gameNotification');
            const titleEl = document.getElementById('notifTitle');
            const messageEl = document.getElementById('notifMessage');
            const buttonsEl = document.getElementById('notifButtons');

            // Remove previous type classes
            modal.className = 'game-notification';
            if (type === 'error') modal.classList.add('error');
            if (type === 'success') modal.classList.add('success');
            if (type === 'warning') modal.classList.add('warning');

            titleEl.textContent = title;
            messageEl.textContent = message;
            buttonsEl.innerHTML = '<button class=\"notif-btn\" onclick=\"closeNotification()\">OK</button>';

            modal.style.display = 'block';
        }

        function showConfirm(message, title = 'CONFIRM') {
            return new Promise((resolve) => {
                const modal = document.getElementById('gameNotification');
                const titleEl = document.getElementById('notifTitle');
                const messageEl = document.getElementById('notifMessage');
                const buttonsEl = document.getElementById('notifButtons');

                modal.className = 'game-notification warning';
                titleEl.textContent = title;
                messageEl.textContent = message;
                buttonsEl.innerHTML = `
                    <button class="notif-btn cancel" onclick="resolveConfirm(false)">CANCEL</button>
                    <button class="notif-btn danger" onclick="resolveConfirm(true)">CONFIRM</button>
                `;

                modal.style.display = 'block';

                // Store resolve function globally for button callbacks
                window.currentConfirmResolve = resolve;
            });
        }

        function closeNotification() {
            document.getElementById('gameNotification').style.display = 'none';
        }

        function resolveConfirm(result) {
            closeNotification();
            if (window.currentConfirmResolve) {
                window.currentConfirmResolve(result);
                window.currentConfirmResolve = null;
            }
        }

        // === VICTORY SCREEN (Phase 12) ===
        async function showVictoryModal(session) {
            // Fetch updated character data to show XP gains
            const teamData = await apiClient.request('GET', `/teams/active`);
            const team = teamData.team || teamData;

            document.getElementById('victoryGrade').textContent = session.performance_grade || 'A';
            document.getElementById('victoryTokens').textContent = session.tokens_earned || 0;

            const xpContainer = document.getElementById('victoryXpBreakdown');
            xpContainer.innerHTML = '';

            // Calculate XP per member
            const activeMembers = team.members.filter(m => !m.is_backup);
            const xpPerMember = Math.floor((session.xp_earned || 0) / activeMembers.length);

            for (const member of activeMembers) {
                const char = member.character;

                // Calculate XP to next level (Pokemon Medium-Fast: Level¬≥)
                const nextLevel = char.level + 1;
                const xpForNext = Math.pow(nextLevel, 3);
                const newXP = char.experience + xpPerMember;
                const xpProgress = Math.min((newXP / xpForNext) * 100, 100);
                const willLevelUp = newXP >= xpForNext;

                const charDiv = document.createElement('div');
                charDiv.style.cssText = 'background: #0f172a; padding: 12px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #3b82f6;';
                charDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="color: #fbbf24; font-size: 11px;">${char.class || 'Character'} Lv.${char.level}</div>
                        <div style="color: #10b981; font-size: 10px;">+${xpPerMember} XP ${willLevelUp ? 'üéâ LEVEL UP!' : ''}</div>
                    </div>
                    <div style="margin-top: 8px;">
                        <div style="background: #1e293b; height: 12px; border-radius: 6px; overflow: hidden; border: 1px solid #475569;">
                            <div style="background: linear-gradient(90deg, #3b82f6, #10b981); height: 100%; width: ${xpProgress}%; transition: width 0.5s;"></div>
                        </div>
                        <div style="color: #94a3b8; font-size: 8px; margin-top: 4px; text-align: center;">
                            ${newXP} / ${xpForNext} XP to Lv.${nextLevel}
                        </div>
                    </div>
                    <div style="color: #94a3b8; font-size: 9px; margin-top: 8px;">
                        HP: ${char.current_hp} | ATK: ${char.current_attack} | DEF: ${char.current_defense}
                    </div>
                `;
                xpContainer.appendChild(charDiv);
            }

            document.getElementById('victoryModal').style.display = 'flex';
        }

        function closeVictoryModal() {
            document.getElementById('victoryModal').style.display = 'none';
            location.reload(); // Refresh to show updated mission unlocks
        }

        // === GLOBAL STATE ===
        let currentSession = null;
        let myTeam = null;
        let maxTeamHP = 0;
        let maxBossHP = 0;

        // === INITIALIZATION ===
        async function init() {
            // AUTH CHECK - Use centralized auth system
            if (!await requireAuth()) {
                return; // requireAuth() handles redirect
            }

            try {
                await loadTeam();
                await loadIslands();
                setupEventListeners();
            } catch (e) {
                console.error('Init error:', e);
                showNotification('Failed to load game data: ' + e.message, 'error', 'LOAD ERROR');
            }
        }

        async function loadTeam() {
            try {
                const res = await apiClient.get('/teams/active');
                myTeam = res;
            } catch (e) {
                console.error('Failed to load team:', e);
            }
        }

        async function loadIslands() {
            try {
                const res = await apiClient.get('/raids/islands');
                // Fix: Backend returns { islands: [...] }
                renderIslands(res.islands || []);
            } catch (e) {
                console.error('Failed to load islands:', e);
            }
        }

        function renderIslands(islands) {
            const grid = document.getElementById('islandsGrid');
            grid.innerHTML = '';

            if (!islands || !Array.isArray(islands)) {
                console.error('Islands data is not an array:', islands);
                return;
            }

            islands.forEach(island => {
                const card = document.createElement('div');
                card.className = 'island-card';
                card.innerHTML = `
                    <div class="island-name">${island.name}</div>
                    <div class="island-difficulty">Difficulty: ${island.difficulty}</div>
                    <div class="island-progress">
                        <div class="island-progress-bar" style="width: 0%"></div>
                    </div>
                    <div style="font-size: 10px; color: #94a3b8; margin-top: 10px;">
                        ${island.description}
                    </div>
                `;
                card.onclick = () => selectIsland(island);
                grid.appendChild(card);
            });
        }

        async function selectIsland(island) {
            try {
                const res = await apiClient.get(`/raids/islands/${island.id}/missions`);
                // Fix: Backend returns { missions: [...] }
                showMissionsModal(island, res.missions || []);
            } catch (e) {
                showNotification('Failed to load missions: ' + e.message, 'error', 'LOAD ERROR');
            }
        }

        function showMissionsModal(island, missions) {
            document.getElementById('modalTitle').textContent = `${island.name} - Missions`;
            const container = document.getElementById('missionsList');
            container.innerHTML = '';

            if (!missions || !Array.isArray(missions)) {
                console.error('Missions data is not an array:', missions);
                container.innerHTML = '<p>No missions found.</p>';
                document.getElementById('missionsModal').style.display = 'flex';
                return;
            }

            missions.forEach(mission => {
                const card = document.createElement('div');
                card.className = 'mission-item';

                // NEW: Apply locked styling
                if (mission.is_locked) {
                    card.classList.add('locked');
                    card.style.opacity = '0.5';
                    card.style.cursor = 'not-allowed';
                }

                card.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 14px; color: #fbbf24;">${mission.is_locked ? '\ud83d\udd12' : '\u2705'} ${mission.name}</div>
                            <div style="font-size: 10px; color: #94a3b8; margin-top: 5px;">${mission.description}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 11px; color: #ef4444;">HP: ${mission.enemy_hp}</div>
                            <div style="font-size: 9px; color: #60a5fa;">Type: ${mission.enemy_type}</div>
                        </div>
                    </div>
                `;

                if (!mission.is_locked) {
                    card.onclick = () => {
                        document.getElementById('missionsModal').style.display = 'none';
                        startMission(mission);
                    };
                } else {
                    card.onclick = () => {
                        showNotification('This mission is locked! Complete the previous mission first.', 'warning', 'LOCKED');
                    };
                }

                container.appendChild(card);
            });

            document.getElementById('missionsModal').style.display = 'flex';
        }

        async function startMission(mission) {
            if (!myTeam) {
                showNotification('You need an active team first!', 'warning', 'NO TEAM');
                return;
            }

            try {
                const res = await apiClient.post('/raids/start', {
                    mission_id: mission.id,
                    team_id: myTeam.id
                });

                document.getElementById('missionsModal').style.display = 'none';
                // Fix: Backend Check confirms StartRaid returns SESSION directly (not wrapped)
                startBattle(res);
            } catch (e) {
                showNotification('Failed to start mission: ' + e.message, 'error', 'START FAILED');
            }
        }

        // Helper to get creative emojis based on type/element (Phase 14 - Unique Sprites)
        function getEmojiSprite(type, element, isBoss = false) {
            // Boss sprites
            if (isBoss) {
                const bossMap = {
                    'FIRE': 'üëπüî•',
                    'ICE': '‚õÑ‚ùÑÔ∏è',
                    'WATER': 'üåäüëæ',
                    'GRASS': 'üåøüëπ',
                    'ELECTRIC': '‚ö°üëª',
                    'DRAGON': 'üê≤',
                    'DARK': 'üòà',
                    'default': 'üëæ'
                };
                return bossMap[element] || bossMap['default'];
            }

            // Character Type Priority Mapping
            const typeMap = {
                'DRAGON': {
                    'FIRE': 'üê≤',
                    'ICE': 'üßäüêâ',
                    'WATER': 'üåäüêâ',
                    'ELECTRIC': '‚ö°üêâ',
                    'default': 'üêâ'
                },
                'BEAST': {
                    'FIRE': 'ü¶Å',
                    'WATER': 'üêã',
                    'GRASS': 'ü¶å',
                    'ELECTRIC': '‚ö°üêÖ',
                    'ICE': 'üêª‚Äç‚ùÑÔ∏è',
                    'default': 'üê∫'
                },
                'BIRD': {
                    'FIRE': 'ü¶Ö',
                    'WATER': 'ü¶Ü',
                    'ELECTRIC': '‚ö°ü¶ú',
                    'ICE': 'ü¶â',
                    'default': 'ü¶ú'
                },
                'INSECT': {
                    'GRASS': 'ü¶ã',
                    'FIRE': 'üêù',
                    'default': 'üêõ'
                },
                'FISH': {
                    'WATER': 'üêü',
                    'ELECTRIC': '‚ö°üê†',
                    'ICE': 'üê°',
                    'default': 'üê†'
                },
                'REPTILE': {
                    'FIRE': 'ü¶é',
                    'WATER': 'üêä',
                    'GRASS': 'üê¢',
                    'default': 'ü¶é'
                },
                'PLANT': {
                    'GRASS': 'üåø',
                    'FIRE': 'üå∂Ô∏è',
                    'default': 'üå±'
                }
            };

            // Class-based mapping (fallback if no type)
            const classMap = {
                'Warrior': '‚öîÔ∏è',
                'Mage': 'üîÆ',
                'Tank': 'üõ°Ô∏è',
                'Archer': 'üèπ',
                'Healer': '‚ú®',
                'Assassin': 'üó°Ô∏è',
                'Paladin': '‚ö°üõ°Ô∏è',
                'Necromancer': 'üíÄ',
                'Druid': 'üåø‚ú®'
            };

            // Element-only mapping (last fallback)
            const elementMap = {
                'FIRE': 'üî•',
                'WATER': 'üíß',
                'GRASS': 'üåø',
                'ELECTRIC': '‚ö°',
                'ICE': '‚ùÑÔ∏è',
                'DRAGON': 'üêâ',
                'DARK': 'üåë',
                'LIGHT': '‚ú®',
                'POISON': '‚ò†Ô∏è',
                'PSYCHIC': 'üîÆ'
            };

            // Priority: Type+Element > Type > Class > Element > Default
            if (type && typeMap[type]) {
                return typeMap[type][element] || typeMap[type]['default'];
            }

            if (type && classMap[type]) {
                return classMap[type];
            }

            if (element && elementMap[element]) {
                return elementMap[element];
            }

            return 'üéÆ'; // Ultimate fallback
        }

        // === BATTLE SYSTEM ===
        function startBattle(session) {
            if (!session || !session.current_team_hp) {
                console.error('Invalid session data:', session);
                showNotification('Failed to start battle: Invalid session data received from server.', 'error', 'BATTLE ERROR');
                return;
            }

            currentSession = session;
            maxBossHP = session.mission.enemy_hp;
            maxTeamHP = session.initial_team_hp || session.current_team_hp;

            // Show battle view
            document.getElementById('worldMapView').style.display = 'none';
            document.getElementById('battleView').style.display = 'block';

            // Set stage name
            document.getElementById('stageName').textContent = session.mission.name;

            // Update Boss Sprite (Emoji)
            const bossSprite = document.getElementById('bossSprite');
            bossSprite.innerHTML = `<div class="emoji-sprite boss anim-idle">${getEmojiSprite(null, session.mission.enemy_type, true)}</div>`;
            bossSprite.style.backgroundImage = 'none';

            // Update Player Sprites (Team)
            const teamSprites = document.getElementById('teamSprites');
            if (!teamSprites) {
                console.error('teamSprites element not found');
                return;
            }
            teamSprites.innerHTML = '';

            if (session.team && session.team.members) {
                session.team.members.forEach((member, idx) => {
                    if (!member.is_backup) {
                        const char = member.character;

                        // Create sprite container
                        const sprite = document.createElement('div');
                        sprite.classList.add('character-sprite');
                        sprite.id = `char${char.id}`;
                        sprite.dataset.charId = char.id;

                        // Emoji sprite
                        const emojiDiv = document.createElement('div');
                        emojiDiv.className = 'character-sprite-img emoji-sprite anim-idle';
                        emojiDiv.textContent = getEmojiSprite(char.character_type || char.class, char.element);

                        // HP bar container
                        const hpContainer = document.createElement('div');
                        hpContainer.className = 'char-hp-container';

                        const hpBarBg = document.createElement('div');
                        hpBarBg.className = 'char-hp-bar-bg';

                        const hpBar = document.createElement('div');
                        hpBar.className = 'char-hp-bar';
                        hpBar.id = `hpBar${char.id}`;
                        hpBar.style.width = '100%';

                        const hpText = document.createElement('span');
                        hpText.className = 'char-hp-text';
                        hpText.id = `hpText${char.id}`;
                        hpText.textContent = `${char.current_hp}/${char.current_hp}`;

                        hpBar.appendChild(hpText);
                        hpBarBg.appendChild(hpBar);
                        hpContainer.appendChild(hpBarBg);

                        sprite.appendChild(emojiDiv);
                        sprite.appendChild(hpContainer);
                        teamSprites.appendChild(sprite);
                    }
                });
            }

            // === PHASE 13: TURN SYSTEM ===
            // Parse turn queue and display current turn
            if (session.turn_queue) {
                try {
                    const turnQueue = JSON.parse(session.turn_queue);
                    updateTurnDisplay(turnQueue, session.current_turn_index || 0);
                    document.getElementById('turnIndicator').style.display = 'block';

                    // Auto-execute if it's enemy's turn
                    const currentTurn = turnQueue[session.current_turn_index % turnQueue.length];
                    if (currentTurn && currentTurn.type === 'enemy') {
                        setTimeout(() => autoExecuteEnemyTurn(), 2000); // 2 sec delay for readability
                    }
                } catch (e) {
                    console.error('Failed to parse turn queue:', e);
                }
            }

            // Update HP bars
            updateBattleUI(session);
            addLog('Battle started!', '#fbbf24');
        }

        function updateBattleUI(session) {
            if (!session) return;

            // Update Boss HP
            const bossPct = (session.current_boss_hp / maxBossHP) * 100;
            document.getElementById('bossHpBar').style.width = bossPct + '%';
            document.getElementById('bossHpText').textContent = `${session.current_boss_hp}/${maxBossHP}`;

            // === PHASE 14: Individual Character HP ===
            if (session.character_states) {
                try {
                    const charStates = JSON.parse(session.character_states);
                    charStates.forEach(state => {
                        updateCharacterHP(state.char_id, state.current_hp, state.max_hp);
                    });
                } catch (e) {
                    console.error('Failed to parse character_states:', e);
                }
            }
        }

        // Update individual character HP bar
        function updateCharacterHP(charID, currentHP, maxHP) {
            const hpBar = document.getElementById(`hpBar${charID}`);
            const hpText = document.getElementById(`hpText${charID}`);
            const charSprite = document.getElementById(`char${charID}`);

            if (!hpBar || !hpText) return;

            const hpPct = (currentHP / maxHP) * 100;
            hpBar.style.width = hpPct + '%';
            hpText.textContent = `${currentHP}/${maxHP}`;

            // Update HP bar color based on percentage
            hpBar.classList.remove('hp-low', 'hp-medium');
            if (hpPct <= 25) {
                hpBar.classList.add('hp-low');
            } else if (hpPct <= 50) {
                hpBar.classList.add('hp-medium');
            }

            // Mark as fainted if HP is 0
            if (charSprite) {
                if (currentHP <= 0) {
                    charSprite.classList.add('fainted');
                } else {
                    charSprite.classList.remove('fainted');
                }
            }
        }

        // === MOVE SELECTION ===
        function showMoveSelection() {
            if (!currentSession) return;

            document.getElementById('mainActionMenu').style.display = 'none';
            document.getElementById('moveSelectionMenu').style.display = 'block';

            const movesGrid = document.getElementById('movesGrid');
            movesGrid.innerHTML = '';

            const team = currentSession.team;

            // === PHASE 13: Get active character from turn queue ===
            let activeChar = null;
            let activeCharID = null;

            if (currentSession.turn_queue) {
                try {
                    const turnQueue = JSON.parse(currentSession.turn_queue);
                    const currentTurn = turnQueue[currentSession.current_turn_index % turnQueue.length];

                    if (currentTurn.type !== 'player') {
                        showNotification('It\'s not your turn! Enemy is acting.', 'warning', '‚ö†Ô∏è NOT YOUR TURN');
                        showMainMenu();
                        return;
                    }

                    // Find the character matching this turn
                    for (let member of team.members) {
                        if (member.character && member.character.id === currentTurn.char_id) {
                            activeChar = member.character;
                            activeCharID = currentTurn.char_id;
                            break;
                        }
                    }
                } catch (e) {
                    console.error('Failed to get active character from turn queue:', e);
                }
            }

            // Fallback to first character (legacy)
            if (!activeChar) {
                for (let member of team.members) {
                    if (!member.is_backup && member.character) {
                        activeChar = member.character;
                        activeCharID = member.character.id;
                        break;
                    }
                }
            }

            if (!activeChar || !activeChar.moves || activeChar.moves.length === 0) {
                movesGrid.innerHTML = '<p style="color: white; text-align: center;">No moves available</p>';
                return;
            }

            activeChar.moves.forEach((move, index) => {
                const btn = document.createElement('button');
                btn.className = `move-btn type-${move.type}`;

                // Check PP and disable if zero
                const isDisabled = move.current_pp <= 0;
                if (isDisabled) {
                    btn.style.opacity = '0.4';
                    btn.style.cursor = 'not-allowed';
                }

                btn.innerHTML = `
                    <div class="move-name">${move.name}</div>
                    <div class="move-info">
                        <span>PWR: ${move.power}</span>
                        <span>PP: ${move.current_pp}/${move.max_pp || move.base_pp}</span>
                    </div>
                `;

                btn.onclick = async () => {
                    if (isDisabled) {
                        showNotification('This move has no PP left!', 'warning', 'NO PP');
                        return;
                    }

                    // Use new turn-based system
                    await executePlayerTurn(activeCharID, index);
                };

                movesGrid.appendChild(btn);
            });
        }

        function hideMoveSelection() {
            document.getElementById('moveSelectionMenu').style.display = 'none';
            document.getElementById('mainActionMenu').style.display = 'grid';
        }

        // Legacy function - redirects to new turn system
        async function useMove(characterId, moveSlot) {
            await executePlayerTurn(characterId, moveSlot - 1);
        }

        // showMainMenu helper
        function showMainMenu() {
            document.getElementById('moveSelectionMenu').style.display = 'none';
            document.getElementById('mainActionMenu').style.display = 'grid';
        }

        function disableControls(disabled) {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = disabled;
            });
        }

        // === HELPER FUNCTIONS ===
        function spawnDamageNumber(amount, className, element) {
            const rect = element.getBoundingClientRect();
            const el = document.createElement('div');
            el.className = `dmg-number ${className}`;
            el.textContent = `-${amount}`;
            el.style.left = (rect.left + rect.width / 2) + 'px';
            el.style.top = (rect.top + rect.height / 2) + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function showFloatingMessage(text, color) {
            const msg = document.createElement('div');
            msg.textContent = text;
            msg.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: ${color};
                font-family: 'Press Start 2P';
                font-size: 20px;
                text-shadow: 3px 3px 0 #000;
                z-index: 1000;
                animation: floatUp 2s ease-out forwards;
            `;
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 2000);
        }

        function addLog(msg, color = '#94a3b8') {
            const log = document.getElementById('battleLog');
            const p = document.createElement('div');
            p.innerHTML = `<span style="color:${color}">${msg}</span>`;
            log.prepend(p);
        }

        function disableControls(disabled) {
            const btns = ['btnFight', 'btnBag', 'btnSwitch', 'btnRun', 'btnBack'];
            btns.forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.disabled = disabled;
            });
        }

        // === EVENT LISTENERS ===
        // Navigation functions
        function showMainMenu() {
            document.getElementById('moveSelectionMenu').style.display = 'none';
            document.getElementById('mainActionMenu').style.display = 'grid';
        }

        async function abandonBattle() {
            const confirmed = await showConfirm('Are you sure you want to abandon this battle? Progress will be lost.');
            if (!confirmed) return;

            try {
                await apiClient.request('POST', `/raids/${currentSession.id}/abandon`);
                showNotification('Battle abandoned successfully. Returning to Island Map...', 'warning', '‚ö†Ô∏è ABANDONED');
                setTimeout(() => location.reload(), 2000);
            } catch (e) {
                showNotification('Failed to abandon battle: ' + e.message, 'error', 'ERROR');
            }
        }

        // === TURN SYSTEM (PHASE 13 - AXIE STYLE) ===

        // Update turn indicator displaying whose turn it is
        function updateTurnDisplay(turnQueue, currentIndex) {
            const turn = turnQueue[currentIndex % turnQueue.length];
            const turnText = document.getElementById('currentTurnText');
            const queuePreview = document.getElementById('turnQueuePreview');

            if (!turn) return;

            // Display current turn
            if (turn.type === 'player') {
                turnText.textContent = `${turn.name}'s Turn!`;
                turnText.style.color = '#10b981'; // Green for player
            } else {
                turnText.textContent = `Enemy's Turn!`;
                turnText.style.color = '#ef4444'; // Red for enemy
            }

            // Show next 3 turns in queue
            const next3 = [];
            for (let i = 1; i <= 3; i++) {
                const nextTurn = turnQueue[(currentIndex + i) % turnQueue.length];
                next3.push(nextTurn.name);
            }
            queuePreview.textContent = `Next: ${next3.join(' ‚Üí ')}`;
        }

        // Auto-execute enemy turn (Phase 14 - With Animations)
        async function autoExecuteEnemyTurn() {
            if (!currentSession) return;

            addLog('üí• Enemy is attacking...', '#ef4444');

            // 1. Animate boss attack
            const bossSprite = document.getElementById('bossSprite');
            if (bossSprite) {
                bossSprite.classList.add('anim-enemy-attack');
                await sleep(300); // Wait for attack animation peak
            }

            try {
                // 2. API Call
                const res = await apiClient.request('POST', `/raids/${currentSession.id}/auto-execute`);
                currentSession = res.session;

                // 3. Display battle result with animations
                if (res.battle_result) {
                    const result = res.battle_result;
                    console.log('Enemy turn result:', result); // DEBUG

                    // Find and animate target character
                    if (result.target_char_id) {
                        console.log('Looking for sprite:', `char${result.target_char_id}`); // DEBUG
                        const targetSprite = document.getElementById(`char${result.target_char_id}`);
                        console.log('Found sprite:', targetSprite); // DEBUG

                        if (targetSprite) {
                            const targetImg = targetSprite.querySelector('.character-sprite-img');
                            console.log('Found img:', targetImg); // DEBUG

                            if (targetImg) {
                                console.log('Adding anim-hit class'); // DEBUG
                                targetImg.classList.add('anim-hit');

                                // Spawn damage number
                                spawnDamageNumber(result.damage, 'enemy-dmg', targetSprite);

                                await sleep(300);
                                targetImg.classList.remove('anim-hit');

                                // Check if character fainted
                                if (result.defender_hp <= 0) {
                                    targetImg.classList.add('anim-faint');
                                    await sleep(500);
                                }
                            } else {
                                console.error('character-sprite-img not found in sprite');
                            }
                        } else {
                            console.error('Target sprite not found:', `char${result.target_char_id}`);
                        }
                    } else {
                        console.error('No target_char_id in result');
                    }

                    addLog(result.message, '#ef4444');
                }

                // 4. Boss returns to position
                if (bossSprite) {
                    bossSprite.classList.remove('anim-enemy-attack');
                }

                await sleep(200);

                // 5. Update UI
                updateBattleUI(currentSession);

                // 6. Update turn display
                if (currentSession.turn_queue) {
                    const turnQueue = JSON.parse(currentSession.turn_queue);
                    updateTurnDisplay(turnQueue, currentSession.current_turn_index);
                }

                // 7. Check if battle ended
                if (currentSession.status !== 'IN_PROGRESS') {
                    handleBattleEnd();
                } else {
                    // Check if next turn is also enemy (shouldn't happen but just in case)
                    const turnQueue = JSON.parse(currentSession.turn_queue);
                    const nextTurn = turnQueue[currentSession.current_turn_index % turnQueue.length];
                    if (nextTurn.type === 'enemy') {
                        setTimeout(() => autoExecuteEnemyTurn(), 2000);
                    }
                }
            } catch (e) {
                console.error('Enemy turn failed:', e);
                showNotification('Enemy turn failed: ' + e.message, 'error', 'BATTLE ERROR');
            }
        }

        // Handle battle end (victory/defeat)
        function handleBattleEnd() {
            if (currentSession.status === 'COMPLETED') {
                setTimeout(async () => {
                    await showVictoryModal(currentSession);
                }, 1500);
            } else if (currentSession.status === 'FAILED') {
                setTimeout(() => {
                    showNotification('DEFEAT! Your team was defeated.', 'error', 'üíÄ DEFEAT');
                    setTimeout(() => location.reload(), 2000);
                }, 1500);
            }
        }

        // Execute player turn (Phase 14 - With Animations)
        async function executePlayerTurn(characterID, moveSlot) {
            if (!currentSession) return;

            // Validate parameters
            if (!characterID || moveSlot === undefined || moveSlot === null) {
                console.error('Invalid parameters:', { characterID, moveSlot });
                showNotification('Invalid move parameters', 'error', 'ERROR');
                return;
            }

            // Disable controls during animation
            disableControls(true);

            // 1. Animate character attack
            const charSprite = document.getElementById(`char${characterID}`);
            if (charSprite) {
                charSprite.querySelector('.character-sprite-img').classList.add('anim-attack');
                await sleep(300); // Wait for attack animation peak
            }

            try {
                // 2. API Call
                const res = await apiClient.request('POST', `/raids/${currentSession.id}/execute-turn`, {
                    character_id: characterID,
                    move_slot: moveSlot
                });

                currentSession = res.session;

                // 3. Display battle result with animations
                if (res.battle_result) {
                    const result = res.battle_result;

                    // Animate boss hit
                    const bossSprite = document.getElementById('bossSprite');
                    if (bossSprite && result.damage > 0) {
                        bossSprite.classList.add('anim-hit');

                        // Spawn damage number
                        const dmgClass = result.effectiveness >= 2.0 ? 'player-dmg-super' :
                            result.effectiveness <= 0.5 ? 'player-dmg-weak' : 'player-dmg';
                        spawnDamageNumber(result.damage, dmgClass, bossSprite);

                        await sleep(300);
                        bossSprite.classList.remove('anim-hit');
                    }

                    addLog(result.message, '#fbbf24');
                }

                // 4. Character returns to position
                if (charSprite) {
                    charSprite.querySelector('.character-sprite-img').classList.remove('anim-attack');
                }

                await sleep(200);

                // 5. Update UI
                updateBattleUI(currentSession);

                // 6. Update turn display
                if (currentSession.turn_queue) {
                    const turnQueue = JSON.parse(currentSession.turn_queue);
                    updateTurnDisplay(turnQueue, currentSession.current_turn_index);
                }

                // 7. Check if battle ended
                if (currentSession.status !== 'IN_PROGRESS') {
                    handleBattleEnd();
                } else {
                    // 8. Check if next turn is enemy's
                    const turnQueue = JSON.parse(currentSession.turn_queue);
                    const nextTurn = turnQueue[currentSession.current_turn_index % turnQueue.length];
                    if (nextTurn.type === 'enemy') {
                        setTimeout(() => autoExecuteEnemyTurn(), 1500); // 1.5s delay before enemy
                    }
                }

                // Hide move selection
                document.getElementById('moveSelectionMenu').style.display = 'none';
                document.getElementById('mainActionMenu').style.display = 'grid';

            } catch (e) {
                console.error('Player turn failed:', e);
                showNotification('Failed to execute move: ' + e.message, 'error', 'BATTLE ERROR');
            } finally {
                disableControls(false);
            }
        }

        // Helper: Sleep/delay function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function setupEventListeners() {
            const btnFight = document.getElementById('btnFight');
            const btnSwitch = document.getElementById('btnSwitch');
            const btnRun = document.getElementById('btnRun');
            const btnCloseModal = document.getElementById('btnCloseModal');

            if (btnFight) btnFight.addEventListener('click', showMoveSelection);
            if (btnSwitch) btnSwitch.addEventListener('click', () => showNotification('Character switching feature coming soon!', 'info', 'IN DEVELOPMENT'));
            if (btnRun) btnRun.addEventListener('click', abandonBattle);
            if (btnCloseModal) btnCloseModal.addEventListener('click', () => {
                document.getElementById('missionsModal').style.display = 'none';
            });
        }

        // Start
        init();
    </script>
    <script src="js/modals.js"></script>
</body>

</html>